
## Ход мыслей

Изначально я подумал, где данный кейс был бы применим. И мне показалось, что хорошо думать о нем как о неком middleware 
до какого-то действия, которым можно было бы спамить, например, отправка сообщения. И нам необходимо сделать AntiFlood систему против спама.

#### Что необходимо?
Нам нужно иметь общее хранилище, в которое будут поступать множественные запросы (в основном запросы на добавление),
а также придумать способ эффективного хранения и извлечения информации о количестве определенных запросов за последние N секунд.

#### Думаем...
Первое, что пришло в голову: иметь любую реляционную БД (например, PostgreSQl). Хранить данные как обычный лог. И каждый 
раз select-ом смотреть сколько было сообщений за последние n секунд. Сложность будет: O(#запросов_за_последние_n_секунд)
Можно, наверное, сделать index. Но это будет O(log#этих_же_запросов), что уже лучше, но есть проблема, что бд будет плохо
от большого количества запросов.

Из вышесказанного понял, что хорошо бы использовать, что-то типа Redis-а. Так как он работает с RAM это будет очень быстро и эффективно.
Можно сделать key - userId, а value - будет счетчиком количества запросов. Но тогда как именно обновлять этот счетчик?
Ну до всего чего я додумался это в RunTime-е ждать каждый запрос пока он не устарее (что-то типо time.After или context.deadline) и после чего уменьшать счетчик.
###### Проблемы
 - Как будто плохо, что будет много спящих горутин, особенно при большом n.
 - И еще будет плохо если вдруг одна из Node упадет(по какой-либо причине), точгда будет некому инкрементить счетчик - и вот это очень плохо.

## Решение
В любом случае Redis это хорошо. Хотелось бы чтобы сам Redis взял задачу удалять объекты, которые нам уже не нужны(livetime < time.Now()-n).
То есть если бы имели set или лист (value) и userId - key, где можно было бы назначить каждому элементу его время жизни + с помощью Len мы бы понимали количество запросов.  
Но к сожалению EXPIRE можно применять только к ключам, а не к "объектам" Redis-а.

Но посмотрев документацию redis-а нашел что для set. Есть вот такие метода для работы с ними [zadd](https://redis.io/commands/zadd/),
[Zrangebyscore](https://redis.io/commands/zrangebyscore/) и [Zcount](https://redis.io/commands/zcount/).
Все они работают за O(log #запросов_определенного_UserID), что намного лучше того с чего мы зачинали.

Суть решения в том, что при добавление запроса, мы пишем его время жизни, то есть time.now() + n. 
Перед каждым запросом мы удаляем все старые запросы [-int, time.Now()].
И просто смотрим количество элементов в сете - это и будет количество запросв за последние n секунд.

## Проблемы и их решение
 - С timestamp-ом в Redis необходимо записывать member чтобы обновлять элемент(в данной задаче это нам не нужно), опэтому я пишу туда просто уникальный id + номер сервиса где он был создан.
 - Также Redis хоть и быстрый, но однопоточный и могут начаться задержки, которые будут искажать правдивость наших данных.
Поэтому можно сделать несколько redis-ов, хэшировать userid-шники и направлять их в нужный instant redis-а (ну и использовать что-то типо консистентного хэширования)

##
Запуск сервиса:
```
docker-compose build
docker-compose up -d
```


## Запрос для тестов

```curl --location --request GET 'http://localhost:8080/user/1234'```


_________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________

Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
